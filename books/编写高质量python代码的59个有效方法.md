# 摘要

## 有数量可变的位置参数减少视觉杂讯

* 在def语句中使用 *args, 即可令函数接收数量可变的位置参数
* 调用函数时，可采用 * 操作符，把序列中的元素当成位置参数，传给该函数
* 对生成器使用 * 操作符，可能导致程序耗尽内存并崩溃
* 在已经接受 *args 参数的函数砂锅面继续添加位置参数，可能会产生难以排查的bug

## 用关键字参数来表达可选的行为

* 位置参数必须出现在关键字参数之前
* 函数参数可以按位置活关键字来指定
* 只是用位置参数来调用函数，可能会导致这些参数值的含义不够明确，而关键字参数则能够阐明每个参数的意图
* 给函数添加新的行为时，可以使用带默认值的关键字参数，以便与原有的函数调用代码保持兼容

## 用只能以关键字形式指定的参数来确保代码清晰

* 关键字参数能够使函数调用的意图更加明确

## 尽量用辅助类来维护程序的状态，而不要使用字典和元组

* 可以使用 from collections import namedtuple. 有一点像类的功能
* 不要使用包含其他字典的字典，也不要使用过长的元组
* 如果容器中包含简单而又不可变的数据，那么可以先使用namedtuple来表示，待稍后有需要时，再修改为完整的类
* 保存内部状态的字典如果变得比较复杂，那么就应该把这些代码拆解为多个辅助类

## 简单的接口应该接受函数，而不是类的实例

* 对于连接各种python组件的简单接口来说，通常应该给其直接传入函数，而不是先定义某个类，然后再传入该类的实例

## 以 @classmethod 形式的堕胎去通用地构建对象

类的多态：使得继承体系中的多个类都能以各自所独有的方式来实现某个方法

* 在python中，每个类只能有一个构造器，也就是__init__方法
* 通过@classmethod机制，可以用一种与构造器相仿的方式类构造类的对象

## 只在使用 Mix-in 组件制作工作类时进行多重继承


## 多用 public 属性，少用 private 属性

* python 编译器无法样额保证 private 字段的私密性
* 不要盲目的将属性设置为 private，而是应该从一开始就做好规划，并允许子类更多的访问超类的内部api

## 继承 collections.abc 以实现自定义的容器类型

    
## 用纯属性取代 get 和 set 方法

* 对于python语言来说，基本上不需要手动实现setter 或 getter 方法，而是应该从简单的 public 属性开始写
* @property 最大的缺点在于，和属性呢相关的方法，只能在子类里面共享。而与之无关的其他类，则无法服用同一份实现代码
* @property 方法应该遵循最小惊讶原则，而不应该产生奇怪的副作用

## 考虑用 @property 来代替属性重构


## 