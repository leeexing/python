## 流畅的python

### 第八章 - 对象的引用、可变性
    变量是标注，而不是盒子
1、不应该将变量理解为`盒子`，应该把变量视作`便利贴`
2、对引用式变量来说，说把变量分配给对象更合理

```css
为了理解 Python 中的赋值语句，应该始终先读右边。对象在
右边创建或获取，在此之后左边的变量才会绑定到对象上，这就像
为对象贴上标注。忘掉盒子吧！

每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会
变；你可以把标识理解为对象在内存中的地址。is 运算符比较两个
对象的标识；id() 函数返回对象标识的整数表示
```

== 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的标识
3、元组的相对不可变性

* 元组的不可变性其实是指 tuple 数据结构的物理内容（即保存的引用）不可变，与引用的对象无关
* 元组的值会随着引用的可变对象的变化而变。元组中不可变的是元素的`标识`。

4、Python 唯一支持的参数传递模式是共享传参 -- 函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名

```css
函数可能会修改作为参数传入的可变对象，但是无
法修改那些对象的标识（即不能把一个对象替换成另一个对象）

>>> a = [1, 2]
>>> b = [3, 4]
>>> f(a, b)
[1, 2, 3, 4]
>>> a, b ➋
([1, 2, 3, 4], [3, 4])
```

4.1、不要使用可变类型作为参数的默认值

```css
默认值在定义函数时计算（通常在加载模块时），
因此默认值变成了函数对象的属性。因此，如果默
认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。
```

### 第九章 - 符合Python风格的对象

    绝对不要使用两个前导下划线，这是很烦人的自私行为

两个概念

* 如何以及何时使用`@classmethod`和`@staticmethod`装饰器
* python的私有属性和受保护属性的用法、约定和局限

1、对象表现形式

* repr() -- 以便于开发者理解的方式返回对象呢的字符串表示形式 | 实现 __repr__ 特殊方法
* str() -- 以便于用户理解的方式返回对象的字符串表示形式 | 实现 __str__ 特殊方法

__repr__、__str__、__format__都必须返回 Unicode字符串(str类型)

2、比较 classmethod 和 staticmethod 的行为
classmethod 改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例。
  classmethod 最常见的用途是定义备选构造方法
staticmethod 装饰器也会改变方法的调用方式，但是第一个参数不是特殊的值。
  其实，静态方法就是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义

```css
>>> class Demo:
...   @classmethod
...   def klassmeth(*args):
...     return args # ➊
...   @staticmethod
...   def statmeth(*args):
...     return args # ➋
...
>>> Demo.klassmeth() # ➌
(<class '__main__.Demo'>,)
>>> Demo.klassmeth('spam')
(<class '__main__.Demo'>, 'spam')
>>> Demo.statmeth() # ➍
()
>>> Demo.statmeth('spam')
('spam',)

不管怎样调用Demo.klassmeth，它的第一个参数始终是 Demo 类

而且知道
staticmethod 不是特别有用
```

3、使用 __slot__ 类属性节省空间
  定义 __slots_s_ 的方式是，创建一个类属性，使用 __slots__ 这个名
字，并把它的值设为一个字符串构成的可迭代对象，其中各个元素表示
各个实例属性。

```css
class Vector2d:
    __slots__ = ('__x', '__y')
    typecode = 'd'
    ...s
```

  使用`元组`可以使得 __slots__ 中所含有的信息不会变化
  在类中定义 __slots__ 属性的目的是告诉解释器：“这个类中的所有实
例属性都在这儿了！”这样，Python 会在各个实例中使用类似元组的结
构存储实例变量，从而避免使用消耗内存的 __dict__ 属性
*注意*
每个子类都要定义 __slots__ 属性，因为解释器会忽略继承的
__slots__ 属性。
实例只能拥有 __slots__ 中列出的属性，除非把 '__dict__' 加
入 __slots__ 中（这样做就失去了节省内存的功效）
如果不把 '__weakref__' 加入 __slots__，实例就不能作为弱引
用的目标

## 第十章 - 序列的修改、散列和切片

本章重点：

* 重点性不强
* 切片原理

1、s[1:4] -- 变成 slice(1, 4, None)